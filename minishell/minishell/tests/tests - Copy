#include "../libft/libft.h"
#include "../src/minishell.h"
#include <stdio.h>
//#include <copyfile.h>

void  test_pipe()
{
	//pipe_exec(pipe_parse("sort"));
	//return;
	pipe_exec(pipe_parse("/bin/ls | /usr/bin/sort"));
	debug_printf("test_pipe OK\n");
	return;
	pipe_exec(pipe_parse("ls"));
	ft_putstr("\n");
	pipe_exec(pipe_parse("ls | cat -e"));
	ft_putstr("\n");
	pipe_exec(pipe_parse("ls | cat -e | sort"));
	ft_putstr("\n");
}

void test_pipe_parse()
{
	t_list* pipe = pipe_parse("ls -l | sort | cat -e");
	t_list* p = pipe;
	//printf("p->content = '%s'\n", (char*)p->content);
	if (!ft_strequ(p->content, "ls -l"))
	{
		printf("p->content != ls -l\n");
		exit(1);
	}
	p = p->next;
	if (!ft_strequ(p->content, "sort"))
	{
		printf("p->content != sort\n");
		exit(1);
	}
	p = p->next;
	//printf("p->content = '%s'\n", (char*)p->content);
	if (!ft_strequ(p->content, "cat -e"))
	{
		printf("p->content != cat -e\n");
		exit(1);
	}
	p = p->next;
	if (p != NULL)
	{
		printf("p->next!=NULL\n");
		exit(1);
	}
	printf("pipe_parse: OK\n");

	pipe_exec(pipe);
	//pipe_free(&pipe);
}
//
//void test_pipe_exec()
//{
//	char str[] = "echo 1";
//	const char** splitted = (const char**) ft_split3(str, " \t");
//	debug_print_zt_array(splitted);
//	char const** pipes[1];
// pipes[0] = splitted;
// pipes[1] = NULL;
//	t_list* pipe = pipe_create(pipes);
//	pipe_exec(pipe);
//	pipe_free(&pipe);
//}

void history()
{
	if (h_has_previous())
	{
		printf("has previous\n");
		exit(1);
	}

	if (h_has_next())
	{
		printf("has next\n");
		exit(1);
	}

	//if (h_get_current() != NULL)
	//{
	//	printf("h_get_current() != NULL\n");
	//	exit(1);
	//}

	h_append(ft_strdup("1"));
	//if (!ft_strequ("1", h_get_current()))
	//{
	//	printf("1!=h_get_current()\n");
	//	exit(1);
	//}

	if (!h_has_previous())
	{
		printf("!has previous\n");
		exit(1);
	}

	if (h_has_next())
	{
		printf("has next\n");
		exit(1);
	}
	h_append(ft_strdup("2"));
	//if (!ft_strequ("2", h_get_current()))
	//{
	//	printf("2!=h_get_current() = '%s'\n", h_get_current());
	//	exit(1);
	//}
	if (!ft_strequ("2", h_get_previous()))
	{
		printf("2!=h_get_previous()\n");
		exit(1);
	}
	if (!ft_strequ("2", h_get_current()))
	{
		printf("2!=h_get_current2()\n");
		exit(1);
	}
	if (h_has_next())
	{
		printf("has next2\n");
		exit(1);
	}
	printf("history: OK\n");
}

void		env()
{
	process_command("setenv q w");
	process_command("echo $q");
	process_command("unsetenv q");
	process_command("echo $q");
	//process_command("set q=w");
	//printf("q = '%s'\n", env_get_value("q"));
	//process_command("set q =q");
	//printf("q = '%s'\n", env_get_value("q"));
	//process_command("set q = e");
	//printf("q = '%s'\n", env_get_value("q"));
}
void		ls()
{
	process_command("ls");
	//process_command("ls -la");
	//process_command("ls -la src");
}

void		cd_bad()
{
	process_command("cd -");
	process_command("cd \\");
}
void		cd_good()
{
	process_command("pwd");
	process_command("cd ~;pwd");
	process_command("cd -");
	//process_command("pwd");
	//process_command("cd ..");
	//process_command("cd /////; pwd");
	//process_command("cd -");
	//process_command("cd; pwd");
	//process_command("cd -");
	//process_command("cd /////; pwd");
	//process_command("cd ..; pwd");
	//process_command("cd ..;pwd;");
}

void		two_commands_good()
{
	process_command("pwd;");
	process_command("echo echo1;;echo echo2");
	process_command("echo echo3;#;echo echo4");
	process_command("echo echo5;echo echo6");
	process_command("echo echo7;echo echo8");
}

void		two_commands_bad()
{
	process_command(";");
	process_command(";;");
	process_command(";;;");
	process_command("; ;");
}

void		echo_tilde()
{
	process_command("echo ~");
}
void		echo_home()
{
	process_command("echo $HOME");
}

void		echo_quotes()
{
	process_command("echo \"q\"");
}
void		pwd()
{
	process_command("pwd");
}
void		comment_ignored()
{
	process_command("#pwd");
	process_command("pwd #");
	process_command("pwd#");
}

#define BUF_SIZE 10
BOOL	compare_buffers(int e_read, int a_read, char e_buf[BUF_SIZE], char a_buf[BUF_SIZE])
{
	if (a_read != e_read)
	{
		printf("a_read: %d, e_read: %d\n", a_read, e_read);
		return (FALSE);
	}
	e_buf[e_read] = 0;
	a_buf[a_read] = 0;
	//printf("e: '%s'(%d) a: '%s'(%d)\n", e_buf, e_read, a_buf, a_read);
	if (!ft_strequ(e_buf, a_buf))
	{
		printf("not eq: e: '%s'(%d) a: '%s'(%d)\n", e_buf, e_read, a_buf, a_read);
		return (FALSE);
	}
	return (TRUE);
}

BOOL		compare_files(const char* expected_file_name, const char* actual_file_name)
{
	//printf("e: %s \na: %s \n", expected_file_name, actual_file_name);
	FILE* a = fopen(actual_file_name, "r");
	if (a == NULL)
	{
		perror(actual_file_name);
		exit(1);
	}
	FILE* e = fopen(expected_file_name, "r");
	if (e == NULL)
	{
		perror(expected_file_name);
		exit(1);
	}
	//printf("e: %s (%p)\na: %s (%p)\n", expected_file_name, e, actual_file_name, a);
	char e_buf[BUF_SIZE];
	char a_buf[BUF_SIZE];
	int e_read;
	while ((e_read = fread(e_buf, 1, BUF_SIZE - 1, e)) > 0)
	{
		int a_read = fread(a_buf, 1, BUF_SIZE - 1, a);
		//e_buf[e_read] = 0;
		//a_buf[a_read] = 0;
		//printf("e: '%s'(%d) a: '%s'(%d)\n", e_buf, e_read, a_buf, a_read);
		//exit(1);
		if (!compare_buffers(e_read, a_read, e_buf, a_buf))
		{
			fclose(a);
			fclose(e);
			return (FALSE);
		}
	}
	BOOL r = (compare_buffers(e_read, fread(a_buf, 1, BUF_SIZE, a), e_buf, a_buf));
	fclose(a);
	fclose(e);
	return (r);
}
void compare_and_free(const char* e, const char* a, const char* name)
{
	if (compare_files(e, a))
	{
		printf("%s: OK\n", name);
	}
	else
	{
		printf("%s: failed\n", name);
		exit(1);
	}
	free((char*)e);
	free((char*)a);
	free((char*)name);
}

void		test(void(*f)(), const char* name)
{
	debug_printf("");
	debug_printf("testing %s\n", name);
	const char* expected_out = ft_strjoin2(3, "test_cases/expected/", name, "_out.txt");
	const char* actual_out = ft_strjoin2(3, "test_cases/actual/", name, "_out.txt");
	const char* expected_err = ft_strjoin2(3, "test_cases/expected/", name, "_err.txt");
	const char* actual_err = ft_strjoin2(3, "test_cases/actual/", name, "_err.txt");
	FILE* f_out = freopen(actual_out, "w", stdout);
	FILE* f_err = freopen(actual_err, "w", stderr);
	f();
	//fflush(file);
	//fflush(stdout);
	//fclose(stdout);
	//char* cmd = ft_strjoin2(4, "cp ", actual_out, " ", ft_strjoin(actual_out, ".copy.txt"));
	//printf("system(%s)\n", cmd);
	//printf("press enter...\n");
	//char ch[10];
	//read(STDIN_FILENO, ch, 10);
	//system(cmd);
	//process_command(cmd);
	//free(cmd);
	freopen("/dev/tty", "a", stdout);
	freopen("/dev/tty", "a", stderr);
	//fseek(f_out, 0, 0);
	//int r = fread(ch,1, 9, f_out);
	//ch[9] = 0;
	//printf("'%s' r = %d\n", ch, r);
	//fclose(f_out);
	compare_and_free(expected_out, actual_out, ft_strjoin(name, "_out"));
	compare_and_free(expected_err, actual_err, ft_strjoin(name, "_err"));
}
void test_pipe2()
{
	int r;
	int w;
	ft_pipe(&r, &w);
	if (ft_fork() == 0) 
	{
	redirect(r, STDIN_FILENO);
	close_fd(w); // just for safety
	exec_ve2("/usr/bin/sort");
	}
		redirect(w, STDOUT_FILENO);
		close_fd(r); // just for safety
		exec_ve2("/bin/ls -l");
}


void test_pipe4()
{
	int pid = ft_fork();
	if (pid == 0)
	{
		int r;
		int w;
		ft_pipe(&r, &w);
		if (ft_fork() == 0)
		{
		redirect(w, STDOUT_FILENO);
		close_fd(r); // just for safety
		exec_ve2("/bin/ls -l");
		}
			redirect(r, STDIN_FILENO);
			close_fd(w); // just for safety
			exec_ve2("/usr/bin/sort");
	}
	wait_child(pid);
}

void test_pipe5(char* cmds[])
{

	int r;
	int w;
	ft_pipe(&r, &w);
	if (ft_fork() == 0)
	{
		redirect(r, STDIN_FILENO);
		close_fd(w); // just for safety
		exec_ve2("/usr/bin/sort");
	}
	redirect(w, STDOUT_FILENO);
	close_fd(r); // just for safety
	exec_ve2("/bin/ls -l");

}

int main(int argc, char** argv, char** envp)
{
	////	char name[] = "test_cases/actual/cd_good_out - cannot open.txt";
	//	char name[] = "test_cases/actual/cd_good_out.txt";
	//	FILE* a = fopen(name, "r");
	//	if (a == NULL)
	//	{
	//		perror(name);
	//		exit(1);
	//	}
	//	printf("ok\n");
		//process_command("pwd");
	//return 0;
	set_out_file("debug_out3.txt", "w");
	set_level(1);
	debug_printf("%s\n", "started");
	signal(SIGINT, ft_default_sig_handler);
	env_from_array(envp);
	ft_putstr("\n\n\n----------------\n\n\n");



	test_pipe2();
	ft_exit(0);
	char** cmds = ft_split3("ls|sort", "|");
	test_pipe5(cmds);
	ft_free_null_term_array((void**)cmds);
	free(cmds);
	ft_exit(0);
	//	test_pipe2();

	test(test_pipe_parse, "test_pipe_parse");
	history();
	//	test(history, "history");
		//return 0;
	test(ls, "ls");
	test(cd_bad, "cd_bad");
	test(cd_good, "cd_good");
	test(pwd, "pwd");
	test(comment_ignored, "comment_ignored");
	test(echo_tilde, "echo_tilde");
	test(echo_home, "echo_home");
	//return 0;
	test(env, "env");
	test(two_commands_bad, "two_commands_bad");
	test(two_commands_good, "two_commands_good");
	test(echo_quotes, "echo_quotes");
	//return (0);
	ft_exit(0);
}
